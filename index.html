<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Octalysis 八角框架分析工具</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #f8fafc;
            font-family: "Microsoft JhengHei", sans-serif;
        }
        .canvas-container {
            position: relative;
            margin: auto;
            height: 60vh;
            width: 100%;
        }
        /* 移除數字輸入框的箭頭 */
        input[type="number"] {
            -moz-appearance: textfield;
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="mx-auto bg-white rounded-2xl shadow-xl overflow-hidden">
        <!-- 標題區 -->
        <div class="flex items-center bg-slate-800 text-white p-6">
            <div>
                <h1 class="text-3xl font-bold mb-2">現況診斷 (Octalysis Analysis)</h1>
                <p class="text-slate-400 mb-4">針對產品/情境，分析 CD1~CD8 的動機元素與驅動力</p>
            </div>
            
            <!-- 分析結果區塊 -->
            <div id="analysis-result" class="ml-auto">
                <div class="">
                    <div class="font-bold mb-1">
                        <span class="text-blue-300">
                            <span id="analysis-score">0</span> 分
                        </span>
                        <span class="font-bold text-white" id="analysis-summary"></span>
                    </div>
                    <div class="text-xs text-slate-400 max-w-lg">
                        <span id="analysis-feedback"></span>
                    </div>
                </div>
            </div>
        </div>

        <div class="flex flex-col lg:flex-row">
            <!-- 左側：圖表主視覺 -->
            <div class="relative lg:w-3/4 p-6 flex flex-col items-center justify-center border-b lg:border-b-0 lg:border-r border-slate-200"
                style="
                    background:
                        linear-gradient(#e5e7eb 4px, transparent 0),
                        linear-gradient(90deg, #e5e7eb 4px, transparent 0),
                        linear-gradient(transparent 50%, #c5cede 0);
                    background-size: 100% 52.25%, 50% 100%, 100% 105%;">
                <span class="font-bold text-[11px] text-slate-500">白帽：帶來希望與掌控感，適合長期體驗（如社群、忠誠計畫）</span>
                <div class="canvas-container">
                    <canvas id="octalysisChart"></canvas>
                </div>
                <span class="font-bold text-[11px] text-slate-500">黑帽：製造焦慮與急迫感，短期強烈但長期可能負面（如限時提示）</span>
                <span class="absolute font-bold left-4 text-[11px] text-slate-500">左腦（外在動機）：<br>行為來自獎勵或目標<br>一旦獎勵消失<br>行為也會停止</span>
                <span class="absolute font-bold right-4 text-[11px] text-slate-500">右腦（內在動機）：<br>行為來自樂趣與情感<br>即使沒有獎勵<br>也會投入</span>
            </div>

            <!-- 右側：控制面板 -->
            <div class="lg:w-1/4 p-6 bg-slate-50 overflow-y-auto" style="height: calc(100dvh - 13rem);">
                <h2 class="text-xl font-bold mb-4 text-slate-700 border-b pb-2 flex justify-between items-center">
                    數據設定
                    <button onclick="resetData()" class="text-xs font-normal px-2 py-1 rounded bg-slate-200 text-slate-600 hover:bg-slate-300 transition">回復預設值</button>
                </h2>
                
                <!-- 目前狀態 (固定) -->
                <div class="mb-6">
                    <h3 class="font-bold text-blue-600 mb-2 flex items-center">
                        <span class="w-3 h-3 bg-blue-500 rounded-full mr-2"></span> 目前現況
                    </h3>
                    <div id="phase-controls-current" class="mb-2"></div>
                    <div id="currentInputs" class="grid grid-cols-2 gap-3">
                        <!-- 動態生成 CD1-CD8 輸入框 -->
                    </div>
                </div>

                <!-- 預計目標 -->
                <div class="mb-6 border-t pt-4">
                    <h3 class="font-bold text-emerald-600 mb-2 flex items-center">
                        <span class="w-3 h-3 bg-emerald-500 rounded-full mr-2"></span> 預計目標
                    </h3>
                    <div id="phase-controls-target" class="mb-2"></div>
                    <div id="targetInputs" class="grid grid-cols-2 gap-3">
                        <!-- 目標分數輸入 -->
                    </div>
                </div>

                <!-- 競品分析 -->
                <div class="mb-6 border-t pt-4">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="font-bold text-orange-600 flex items-center">
                            <span class="w-3 h-3 bg-orange-500 rounded-full mr-2"></span> 競品對比
                        </h3>
                        <button onclick="addCompetitor()" class="text-xs px-2 py-1 rounded bg-orange-100 text-orange-700 hover:bg-orange-200 transition">+ 新增競品</button>
                    </div>
                    <div id="competitorList" class="space-y-4">
                        <!-- 競品列表區域 -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * Octalysis 核心計分與評分邏輯 (已翻譯為台灣繁體中文)
         */
        const OctalysisCalculator = {
            // 定義評語常數
            TEXTS: {
                summary: {
                    initial: "你的 Octalysis 分析",
                    whiteHat: "白帽設計 (White Hat)",
                    blackHat: "黑帽設計 (Black Hat)",
                    proudOfYou: "為你感到驕傲",
                    weakExperience: "體驗薄弱",
                    leftBrain: "左腦導向 (Left Brain)",
                    rightBrain: "右腦導向 (Right Brain)",
                    goodMotivation: "動機平衡良好",
                    fallingAsleep: "令人昏昏欲睡",
                    anotherDay: "改天再說"
                },
                feedback: {
                    initial: "請調整上方的滑桿來設定核心驅動力數值，並設定你的專案標題與副標題。\n你也可以為專案設定 Logo。",
                    whiteHat: "你的體驗設計重度偏向「白帽」核心驅動力，這意味著使用者感覺很棒且充滿力量。缺點是使用者缺乏執行期望行動的急迫感。試著加入一些輕度的「黑帽」技巧來為體驗增添一點刺激感。",
                    blackHat: "你的體驗設計重度偏向「黑帽」核心驅動力，這意味著驅動使用者行為的效果極佳，但使用者可能感覺不好，長期下來可能會離開你的系統（想想某些 Zynga 的產品）。強烈建議加入「白帽」技巧，讓使用者在不由自主地採取行動後，也能感覺良好。",
                    proudOfYou: "你的體驗在「白帽」與「黑帽」核心驅動力上相當平衡。真為你感到驕傲 ;-)",
                    weakExperience: "你的體驗在「白帽」與「黑帽」核心驅動力上都很弱。你知道這種兩邊都不敢下注的保守做法，是無法帶你到達任何目標的嗎？",
                    leftBrain: "此外，你的「左腦」核心驅動力比「右腦」強很多，意味著你的體驗本質上更偏向「外在動機」。這可能會影響長期參與度，因為一旦獎勵目標被移除或減少，使用者就會失去動機。考慮加入更多「右腦」核心驅動力，讓活動本身就變得有趣！",
                    rightBrain: "此外，你的「右腦」核心驅動力比「左腦」強很多，意味著你的體驗本質上更偏向「內在動機」。這很棒，因為使用者真心享受你的體驗。你也可以考慮加入更多「左腦」遊戲化技巧，增加成就感、深層的所有權以及受控的限制設計，來讓體驗更豐富有趣。",
                    goodMotivation: "此外，你在「左腦」與「右腦」核心驅動力之間似乎取得了很好的平衡，這意味著你可能有很好的內在與外在動機平衡。但請務必小心，因為設計不良的外在動機可能會扼殺原有的內在動機。",
                    fallingAsleep: "嗯，看起來你的體驗無論在「右腦」還是「左腦」核心驅動力上都不強，這意味著你的內在與外在動機都很薄弱。看著看著我都快睡著了。",
                    anotherDay: "我剛剛對你的體驗有個可以改變你一生的絕妙洞見。但我看... 還是改天再告訴你好了。"
                }
            },

            // 將輸入物件轉換為特定順序的陣列
            // 順序: [CD1, CD3, CD5, CD7, CD8, CD6, CD4, CD2]
            getScoreArray(data) {
                return [
                    data.CD1, // Index 0: 史詩意義與使命感
                    data.CD3, // Index 1: 賦予創造能力與回饋
                    data.CD5, // Index 2: 社會影響力與同理心
                    data.CD7, // Index 3: 未知性與好奇心
                    data.CD8, // Index 4: 損失與避免
                    data.CD6, // Index 5: 稀缺性與迫切感
                    data.CD4, // Index 6: 所有權與佔有慾
                    data.CD2  // Index 7: 發展與成就感
                ];
            },

            // 計算總分 (平方和)
            getTotalScore(arr) {
                return arr.map(s => Math.pow(s, 2)).reduce((a, b) => a + b, 0);
            },

            // 計算白帽分數
            getWhiteHatScore(t) {
                return (5 * t[0]) + (3 * t[7]) + (3 * t[1]) + (1 * t[6]) + (1 * t[2]);
            },

            // 計算黑帽分數
            getBlackHatScore(t) {
                return (5 * t[4]) + (3 * t[3]) + (3 * t[5]) + (1 * t[2]) + (1 * t[6]);
            },

            // 計算右腦分數
            getRightBrainScore(t) {
                return (5 * t[2]) + (3 * t[1]) + (3 * t[3]) + (1 * t[0]) + (1 * t[4]);
            },

            // 計算左腦分數
            getLeftBrainScore(t) {
                return (5 * t[6]) + (3 * t[5]) + (3 * t[7]) + (1 * t[0]) + (1 * t[4]);
            },

            // 主要分析函數
            analyze(inputData) {
                const arr = this.getScoreArray(inputData);
                
                const totalScore = this.getTotalScore(arr);
                const wh = this.getWhiteHatScore(arr);
                const bh = this.getBlackHatScore(arr);
                const lb = this.getLeftBrainScore(arr);
                const rb = this.getRightBrainScore(arr);

                let summary = "";
                let feedback = "";

                // 判斷基礎狀態 (全為0)
                if (wh === 0 && bh === 0 && lb === 0 && rb === 0) {
                    return {
                        score: totalScore,
                        summary: this.TEXTS.summary.initial,
                        feedback: this.TEXTS.feedback.initial
                    };
                }

                // --- 第一階段：白帽 vs 黑帽 ---
                if (wh > 40 && (2 * bh) < wh) {
                    summary = this.TEXTS.summary.whiteHat;
                    feedback = this.TEXTS.feedback.whiteHat;
                } else if (bh > 40 && (2 * wh) < bh) {
                    summary = this.TEXTS.summary.blackHat;
                    feedback = this.TEXTS.feedback.blackHat;
                } else if (wh > 40 && bh > 40) {
                    summary = this.TEXTS.summary.proudOfYou;
                    feedback = this.TEXTS.feedback.proudOfYou;
                } else if (wh < 40 && bh < 40) {
                    summary = this.TEXTS.summary.weakExperience;
                    feedback = this.TEXTS.feedback.weakExperience;
                }

                // 處理 Feedback 連接詞
                if (feedback !== "") {
                    feedback += " / ";
                }

                // --- 第二階段：左腦 vs 右腦 ---
                // 處理 Summary 連接詞 (如果前面有內容，加 " 以及 ")
                const summaryPrefix = summary !== "" ? " 以及 " : "";

                if (lb > 40 && (2 * rb) < lb) {
                    summary += summaryPrefix + this.TEXTS.summary.leftBrain;
                    feedback += this.TEXTS.feedback.leftBrain;
                } else if (rb > 40 && (2 * lb) < rb) {
                    summary += summaryPrefix + this.TEXTS.summary.rightBrain;
                    feedback += this.TEXTS.feedback.rightBrain;
                } else if (rb > 40 && lb > 40) {
                    summary += summaryPrefix + this.TEXTS.summary.goodMotivation;
                    feedback += this.TEXTS.feedback.goodMotivation;
                } else if (rb < 40 && lb < 40) {
                    summary += summaryPrefix + this.TEXTS.summary.fallingAsleep;
                    feedback += this.TEXTS.feedback.fallingAsleep;
                }

                // 如果最後 summary 還是空的
                if (summary === "") {
                    summary = this.TEXTS.summary.anotherDay;
                    feedback = this.TEXTS.feedback.anotherDay;
                }

                return {
                    score: totalScore,
                    metrics: {
                        whiteHat: wh,
                        blackHat: bh,
                        leftBrain: lb,
                        rightBrain: rb
                    },
                    summary: summary,
                    feedback: feedback
                };
            }
        };

        // 1. 定義圖表上的標籤順序 (維持您原本的設定，這決定了雷達圖軸線的順序)
        // 順序: CD1, CD3, CD5, CD7, CD8, CD6, CD4, CD2 (對應 index 0~7)
        const chartLabels = [
            'CD1 重大使命與呼召',
            'CD3 賦予創造力與回饋',
            'CD5 社交影響力與同理心',
            'CD7 不確定性與好奇心',
            'CD8 損失與避免',
            'CD6 稀缺性與迫切',
            'CD4 所有權與佔有欲',
            'CD2 發展與成就'
        ];

        // 2. 定義輸入框的順序與對應關係 (這是給使用者看的，依照 CD1~CD8 排序)
        // dataIndex 指向 chartLabels 陣列中的位置
        const inputConfig = [
            { code: 'CD1', label: '重大使命與呼召', dataIndex: 0 },
            { code: 'CD2', label: '發展與成就', dataIndex: 7 }, // 在 chartLabels 的最後一個
            { code: 'CD3', label: '賦予創造力與回饋', dataIndex: 1 },
            { code: 'CD4', label: '所有權與佔有欲',   dataIndex: 6 },
            { code: 'CD5', label: '社交影響力與同理心', dataIndex: 2 },
            { code: 'CD6', label: '稀缺性與迫切', dataIndex: 5 },
            { code: 'CD7', label: '不確定性與好奇心', dataIndex: 3 },
            { code: 'CD8', label: '損失與避免', dataIndex: 4 }
        ];

        // --- 4-Phase Configuration ---
        const PHASES = [
            { id: 0, name: "發現", tooltip: "讓人願意「試試看」" },
            { id: 1, name: "引導", tooltip: "讓人「會用，且立刻看到收穫」" },
            { id: 2, name: "成長", tooltip: "讓人「日常性地回來並持續下去」" },
            { id: 3, name: "終局", tooltip: "讓資深用戶「擁有地位與持續任務，避免倦怠」" }
        ];

        // UI State to track active editing phase and visibility
        const uiState = {
            current: { activePhase: 0, visiblePhases: [true, false, false, false] },
            target: { activePhase: 0, visiblePhases: [false, false, false, false] }, // 預設圖表關閉
            competitors: {} // Map by ID
        };
        // -----------------------------

        let chart;
        
        // 預設數據 (4 Phases)
        const defaultDatasets = {
             current: [
                [5, 4, 6, 3, 5, 2, 4, 3], // Discovery
                [3, 3, 3, 3, 3, 3, 3, 3], // Onboarding
                [3, 3, 3, 3, 3, 3, 3, 3], // Scaffolding
                [3, 3, 3, 3, 3, 3, 3, 3]  // Endgame
             ], 
             target: [
                [8, 8, 7, 6, 7, 5, 6, 4], // Discovery
                [6, 6, 6, 6, 6, 6, 6, 6],
                [6, 6, 6, 6, 6, 6, 6, 6],
                [6, 6, 6, 6, 6, 6, 6, 6]
             ],
             competitors: [] 
        };

        // 嘗試從 localStorage 讀取，否則使用預設
        let datasets = loadData() || JSON.parse(JSON.stringify(defaultDatasets));

        // Migration Check: If old format (single array), convert to 4-phase
        if (datasets.current && !Array.isArray(datasets.current[0])) {
            console.log("Migrating current/target data to 4-phase format...");
            datasets.current = [datasets.current, [...defaultDatasets.current[1]], [...defaultDatasets.current[2]], [...defaultDatasets.current[3]]];
            datasets.target = [datasets.target, [...defaultDatasets.target[1]], [...defaultDatasets.target[2]], [...defaultDatasets.target[3]]];
            
            // Migrate competitors
            datasets.competitors.forEach(comp => {
                if (comp.data && !Array.isArray(comp.data[0])) {
                    comp.data = [comp.data, [3,3,3,3,3,3,3,3], [3,3,3,3,3,3,3,3], [3,3,3,3,3,3,3,3]];
                }
            });
            saveData();
        }
        
        // Initialize UI State for competitors
        datasets.competitors.forEach(comp => {
            if (!uiState.competitors[comp.id]) {
                uiState.competitors[comp.id] = { activePhase: 0, visiblePhases: [true, false, false, false] };
            }
        });

        const colors = [
            'rgba(249, 115, 22, 0.7)', // Orange
            'rgba(168, 85, 247, 0.7)', // Purple
            'rgba(236, 72, 153, 0.7)', // Pink
            'rgba(20, 184, 166, 0.7)'  // Teal
        ];

        // --- Data Persistence Functions ---
        function saveData() {
            localStorage.setItem('octalysisData', JSON.stringify(datasets));
        }

        function loadData() {
            const data = localStorage.getItem('octalysisData');
            return data ? JSON.parse(data) : null;
        }

        function resetData() {
            if(confirm('確定要自瀏覽器清除所有設定並回復預設值嗎？')) {
                // Reset Data
                datasets = JSON.parse(JSON.stringify(defaultDatasets));
                saveData();
                
                // Reset UI State
                uiState.current = { activePhase: 0, visiblePhases: [true, false, false, false] };
                uiState.target = { activePhase: 0, visiblePhases: [false, false, false, false] }; // 預設圖表關閉
                uiState.competitors = {};

                // Re-initialize everything
                createPhaseControls('phase-controls-current', 'current');
                createPhaseControls('phase-controls-target', 'target');
                initChart();
                createInputGroup('currentInputs', datasets.current, 'current');
                createInputGroup('targetInputs', datasets.target, 'target');
                renderCompetitorList();
                updateAnalysisResult();
            }
        }
        // ----------------------------------

        function initChart() {
            const ctx = document.getElementById('octalysisChart').getContext('2d');
            
            // Helper to generate chart datasets for a group (e.g. current, target, or competitor)
            const generateDatasets = (dataGroup, baseLabel, baseColor, type, entityId = null) => {
                const datasets = [];
                // dataGroup is array of 4 arrays
                PHASES.forEach((phase, phaseIdx) => {
                    // Check visibility state
                    let isVisible = false;
                    if (type === 'competitor') {
                        if (uiState.competitors[entityId]) {
                            isVisible = uiState.competitors[entityId].visiblePhases[phaseIdx];
                        }
                    } else {
                        isVisible = uiState[type].visiblePhases[phaseIdx];
                    }

                    // Define style based on phase
                    let borderDash = [];
                    if (phaseIdx === 1) borderDash = [5, 5];
                    else if (phaseIdx === 2) borderDash = [2, 3];
                    else if (phaseIdx === 3) borderDash = [10, 5];

                    let bg = baseColor.replace('0.7', '0.1').replace('rgb', 'rgba').replace(')', ', 0.1)'); 
                    if (baseColor.startsWith('rgba')) {
                         bg = baseColor.replace(/[\d.]+\)$/, '0.1)');
                    }

                    datasets.push({
                        label: `${baseLabel} - ${phase.name}`,
                        data: dataGroup[phaseIdx],
                        borderColor: baseColor,
                        backgroundColor: bg,
                        borderWidth: 2,
                        borderDash: borderDash,
                        pointRadius: isVisible ? 3 : 0, 
                        hidden: !isVisible,
                        fill: true
                    });
                });
                return datasets;
            };

            const currentDatasets = generateDatasets(datasets.current, '目前', 'rgb(59, 130, 246)', 'current');
            const targetDatasets = generateDatasets(datasets.target, '目標', 'rgb(16, 185, 129)', 'target');
            
            let allDatasets = [...currentDatasets, ...targetDatasets];

            datasets.competitors.forEach(comp => {
                const compDs = generateDatasets(comp.data, comp.name, comp.color, 'competitor', comp.id);
                allDatasets = [...allDatasets, ...compDs];
            });

            const chartData = {
                labels: chartLabels,
                datasets: allDatasets
            };

            if (chart) {
                chart.destroy();
            }

            chart = new Chart(ctx, {
                type: 'radar',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            angleLines: { color: '#e2e8f0' },
                            grid: { color: '#e2e8f0' },
                            suggestedMin: 0,
                            suggestedMax: 10,
                            ticks: { stepSize: 2, display: false },
                            pointLabels: {
                                font: { size: 14, weight: 'bold' },
                                color: '#475569'
                            }
                        }
                    },
                    plugins: {
                        legend: { 
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;
                                }
                            }
                        }
                    }
                }
            });
        }

        // --- New Helper Functions for Phase Control ---
        function createPhaseControls(containerId, type, entityId = null) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            let html = `<div class="flex space-x-1 mb-3 overflow-x-auto pb-1">`;
            
            PHASES.forEach((phase, idx) => {
                let isActive = false;
                let isVisible = false;
                
                if (type === 'competitor') {
                    if (uiState.competitors[entityId]) {
                        isActive = uiState.competitors[entityId].activePhase === idx;
                        isVisible = uiState.competitors[entityId].visiblePhases[idx];
                    }
                } else {
                    isActive = uiState[type].activePhase === idx;
                    isVisible = uiState[type].visiblePhases[idx];
                }

                const idStr = entityId ? `'${entityId}'` : 'null';
                const clickFn = `setActivePhase('${type}', ${idStr}, ${idx})`;
                const toggleFn = `togglePhaseVisibility(event, '${type}', ${idStr}, ${idx})`;

                const activeClass = isActive ? 'bg-slate-700 text-white shadow-md' : 'bg-white text-slate-600 border border-slate-200 hover:bg-slate-50';
                const eyeClass = isVisible ? 'text-blue-500' : 'text-slate-300';
                
                html += `
                    <button onclick="${clickFn}" title="${phase.tooltip}" 
                        class="flex items-center space-x-1 px-3 py-1.5 rounded-full text-xs transition ${activeClass} whitespace-nowrap group relative">
                        <span>${phase.name}</span>
                        <span onclick="${toggleFn}" class="ml-1 p-0.5 rounded-full hover:bg-slate-200 cursor-pointer ${eyeClass}" title="切換圖表顯示">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                                <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" />
                            </svg>
                        </span>
                    </button>
                `;
            });
            html += `</div>`;
            container.innerHTML = html;
        }

        function setActivePhase(type, entityId, phaseIdx) {
            if (type === 'competitor') {
                uiState.competitors[entityId].activePhase = phaseIdx;
                if (!uiState.competitors[entityId].visiblePhases[phaseIdx]) {
                     uiState.competitors[entityId].visiblePhases[phaseIdx] = true;
                }
            } else {
                uiState[type].activePhase = phaseIdx;
                 if (!uiState[type].visiblePhases[phaseIdx]) {
                     uiState[type].visiblePhases[phaseIdx] = true;
                }
            }
            
            const controlId = entityId ? `phase-controls-comp-${entityId}` : `phase-controls-${type}`;
            createPhaseControls(controlId, type, entityId);

            const inputId = entityId ? `comp-grid-${entityId}` : `${type}Inputs`;
            let compIdx = null;
            if (type === 'competitor') {
                compIdx = datasets.competitors.findIndex(c => c.id == entityId); // Note: entityId might be string from HTML
            }
            
            if (type === 'current') {
                createInputGroup('currentInputs', datasets.current[phaseIdx], 'current'); // Pass specific phase data
            } else if (type === 'target') {
                createInputGroup('targetInputs', datasets.target[phaseIdx], 'target');
            } else if (type === 'competitor' && compIdx !== -1) {
                createInputGroup(inputId, null, 'competitor', compIdx); 
            }

            initChart(); 
        }

        function togglePhaseVisibility(e, type, entityId, phaseIdx) {
            e.stopPropagation(); 
            
             if (type === 'competitor') {
                uiState.competitors[entityId].visiblePhases[phaseIdx] = !uiState.competitors[entityId].visiblePhases[phaseIdx];
            } else {
                uiState[type].visiblePhases[phaseIdx] = !uiState[type].visiblePhases[phaseIdx];
            }

            const controlId = entityId ? `phase-controls-comp-${entityId}` : `phase-controls-${type}`;
            createPhaseControls(controlId, type, entityId);
            
            initChart();
        }
        // ---------------------------------------------

        // 修改後的生成輸入框函數
        function createInputGroup(containerId, dataArray, type, competitorIndex = null) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';
            
            let activeData = dataArray;
            let activePhaseIdx = 0;

            if (type === 'competitor') {
                const comp = datasets.competitors[competitorIndex];
                activePhaseIdx = uiState.competitors[comp.id].activePhase;
                activeData = comp.data[activePhaseIdx];
            } else if (type === 'current') {
                activePhaseIdx = uiState.current.activePhase;
                activeData = datasets.current[activePhaseIdx];
            } else if (type === 'target') {
                 activePhaseIdx = uiState.target.activePhase;
                 activeData = datasets.target[activePhaseIdx];
            }

            inputConfig.forEach((item) => {
                const div = document.createElement('div');
                div.className = 'flex flex-col relative group';
                
                const labelText = document.createElement('label');
                labelText.className = 'text-[11px] font-bold text-slate-500 mb-1';
                labelText.innerText = `${item.code} ${item.label}`;
                
                const input = document.createElement('input');
                input.type = 'number';
                input.min = 0;
                input.max = 10;
                input.value = activeData[item.dataIndex]; 
                
                let ringColor = 'focus:ring-blue-400';
                if(type === 'target') ringColor = 'focus:ring-emerald-400';
                if(type === 'competitor') ringColor = 'focus:ring-orange-400';

                input.className = `border border-slate-300 rounded px-2 py-1 text-sm focus:ring-2 ${ringColor} outline-none transition shadow-sm`;
                
                input.oninput = (e) => {
                    let val = parseInt(e.target.value) || 0;
                    if (val > 10) val = 10;
                    if (val < 0) val = 0;
                    
                    if (competitorIndex !== null) {
                        datasets.competitors[competitorIndex].data[activePhaseIdx][item.dataIndex] = val;
                        initChart(); 
                    } else if (type === 'current') {
                        datasets.current[activePhaseIdx][item.dataIndex] = val;
                        initChart();
                        updateAnalysisResult(); 
                    } else if (type === 'target') {
                        datasets.target[activePhaseIdx][item.dataIndex] = val;
                        initChart();
                    }
                    saveData(); 
                };

                div.appendChild(labelText);
                div.appendChild(input);
                container.appendChild(div);
            });
            
            if (type === 'current') updateAnalysisResult();
        }

        function toggleDataset(type) {
            const btn = document.getElementById(`btn-${type}`);
            let inputArea = document.getElementById(`${type}InputsContainer`); // Try container first
            if (!inputArea) inputArea = document.getElementById(`${type}Inputs`);

            // Toggle visibility of the input area section
            inputArea.classList.toggle('hidden');
            btn.innerText = inputArea.classList.contains('hidden') ? '顯示' : '隱藏';
        }

        function addCompetitor() {
            const id = Date.now();
            const color = colors[datasets.competitors.length % colors.length];
            const newComp = {
                id: id,
                name: `競品 ${datasets.competitors.length + 1}`,
                data: [
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3]
                ],
                color: color
            };
            
            uiState.competitors[id] = { activePhase: 0, visiblePhases: [true, false, false, false] };

            datasets.competitors.push(newComp);
            renderCompetitorList();
            initChart();
            saveData(); 
        }

        function removeCompetitor(id) {
            datasets.competitors = datasets.competitors.filter(c => c.id !== id);
            delete uiState.competitors[id];
            renderCompetitorList();
            initChart();
            saveData(); 
        }

        function renderCompetitorList() {
            const container = document.getElementById('competitorList');
            container.innerHTML = '';

            datasets.competitors.forEach((comp, idx) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'bg-white p-4 rounded-lg border border-slate-200 shadow-sm transition hover:shadow-md';
                
                const header = document.createElement('div');
                header.className = 'flex justify-between items-center mb-3 pb-2 border-b border-dashed border-slate-200';
                
                const nameWrapper = document.createElement('div');
                nameWrapper.className = 'flex items-center gap-2 w-full';
                
                const colorDot = document.createElement('div');
                colorDot.className = 'w-3 h-3 rounded-full';
                colorDot.style.backgroundColor = comp.color;

                const nameInput = document.createElement('input');
                nameInput.value = comp.name;
                nameInput.className = 'font-bold text-sm bg-transparent border-none focus:ring-0 text-slate-700 w-2/3';
                nameInput.oninput = (e) => {
                    comp.name = e.target.value;
                    initChart(); 
                    saveData(); 
                };

                const delBtn = document.createElement('button');
                delBtn.innerHTML = '✕ 移除';
                delBtn.className = 'text-slate-400 hover:text-red-500 text-xs ml-auto whitespace-nowrap px-2';
                delBtn.onclick = () => removeCompetitor(comp.id);

                nameWrapper.appendChild(colorDot);
                nameWrapper.appendChild(nameInput);
                nameWrapper.appendChild(delBtn);
                header.appendChild(nameWrapper);
                wrapper.appendChild(header);

                // Phase Controls
                const phaseControlId = `phase-controls-comp-${comp.id}`;
                const phaseControlDiv = document.createElement('div');
                phaseControlDiv.id = phaseControlId;
                wrapper.appendChild(phaseControlDiv);

                const gridId = `comp-grid-${comp.id}`;
                const grid = document.createElement('div');
                grid.id = gridId;
                grid.className = 'grid grid-cols-4 gap-x-2 gap-y-3';
                wrapper.appendChild(grid);
                
                container.appendChild(wrapper);
                
                // Render Controls & Inputs
                if (!uiState.competitors[comp.id]) {
                     uiState.competitors[comp.id] = { activePhase: 0, visiblePhases: [true, false, false, false] };
                }
                createPhaseControls(phaseControlId, 'competitor', comp.id);
                createInputGroup(gridId, null, 'competitor', idx);
            });
        }

        function updateChart() {
            // 保留前兩個基礎 Dataset (目前與預計)
            const baseDatasets = chart.data.datasets.slice(0, 2);
            
            // 重新加上競品 Dataset
            const compDatasets = datasets.competitors.map(comp => ({
                label: comp.name,
                data: comp.data,
                backgroundColor: comp.color.replace('0.7', '0.1'),
                borderColor: comp.color,
                pointBackgroundColor: comp.color,
                borderWidth: 2,
                fill: true
            }));

            chart.data.datasets = [...baseDatasets, ...compDatasets];
            chart.update();
        }

        // 新增：更新分析結果的函數
        // 新增：更新分析結果的函數
        function updateAnalysisResult() {
            // Analyze the ACTIVE PHASE of Current
            const activePhase = uiState.current.activePhase;
            const currentData = datasets.current[activePhase] || datasets.current[0]; // Fallback

            const inputData = {};
            inputData.CD1 = currentData[0] || 0;
            inputData.CD3 = currentData[1] || 0;
            inputData.CD5 = currentData[2] || 0;
            inputData.CD7 = currentData[3] || 0;
            inputData.CD8 = currentData[4] || 0;
            inputData.CD6 = currentData[5] || 0;
            inputData.CD4 = currentData[6] || 0;
            inputData.CD2 = currentData[7] || 0;

            const result = OctalysisCalculator.analyze(inputData);

            // 更新 UI - Using correct IDs
            const resultDiv = document.getElementById('analysis-result');
            const scoreSpan = document.getElementById('analysis-score');
            const summarySpan = document.getElementById('analysis-summary');
            const feedbackSpan = document.getElementById('analysis-feedback');

            if (result && resultDiv) {
                resultDiv.classList.remove('hidden');
                scoreSpan.innerText = result.score;
                summarySpan.innerText = result.summary;
                feedbackSpan.innerText = result.feedback;
            }
        }

        window.onload = () => {
            // Wait for DOM
            createPhaseControls('phase-controls-current', 'current');
            createPhaseControls('phase-controls-target', 'target');
            
            initChart();
            createInputGroup('currentInputs', datasets.current, 'current');
            updateAnalysisResult(); // 新增：初始化時執行一次分析
            createInputGroup('targetInputs', datasets.target, 'target');
            renderCompetitorList(); // 渲染競品列表
        };
    </script>
</body>
</html>
